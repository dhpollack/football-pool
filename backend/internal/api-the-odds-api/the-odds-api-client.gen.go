// Package theoddsapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package theoddsapi

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for GetV4HistoricalSportsSportEventsParamsDateFormat.
const (
	GetV4HistoricalSportsSportEventsParamsDateFormatIso  GetV4HistoricalSportsSportEventsParamsDateFormat = "iso"
	GetV4HistoricalSportsSportEventsParamsDateFormatUnix GetV4HistoricalSportsSportEventsParamsDateFormat = "unix"
)

// Defines values for GetV4HistoricalSportsSportEventsEventIdOddsParamsRegions.
const (
	GetV4HistoricalSportsSportEventsEventIdOddsParamsRegionsAu    GetV4HistoricalSportsSportEventsEventIdOddsParamsRegions = "au"
	GetV4HistoricalSportsSportEventsEventIdOddsParamsRegionsEu    GetV4HistoricalSportsSportEventsEventIdOddsParamsRegions = "eu"
	GetV4HistoricalSportsSportEventsEventIdOddsParamsRegionsUk    GetV4HistoricalSportsSportEventsEventIdOddsParamsRegions = "uk"
	GetV4HistoricalSportsSportEventsEventIdOddsParamsRegionsUs    GetV4HistoricalSportsSportEventsEventIdOddsParamsRegions = "us"
	GetV4HistoricalSportsSportEventsEventIdOddsParamsRegionsUs2   GetV4HistoricalSportsSportEventsEventIdOddsParamsRegions = "us2"
	GetV4HistoricalSportsSportEventsEventIdOddsParamsRegionsUsDfs GetV4HistoricalSportsSportEventsEventIdOddsParamsRegions = "us_dfs"
)

// Defines values for GetV4HistoricalSportsSportEventsEventIdOddsParamsDateFormat.
const (
	GetV4HistoricalSportsSportEventsEventIdOddsParamsDateFormatIso  GetV4HistoricalSportsSportEventsEventIdOddsParamsDateFormat = "iso"
	GetV4HistoricalSportsSportEventsEventIdOddsParamsDateFormatUnix GetV4HistoricalSportsSportEventsEventIdOddsParamsDateFormat = "unix"
)

// Defines values for GetV4HistoricalSportsSportEventsEventIdOddsParamsOddsFormat.
const (
	GetV4HistoricalSportsSportEventsEventIdOddsParamsOddsFormatAmerican GetV4HistoricalSportsSportEventsEventIdOddsParamsOddsFormat = "american"
	GetV4HistoricalSportsSportEventsEventIdOddsParamsOddsFormatDecimal  GetV4HistoricalSportsSportEventsEventIdOddsParamsOddsFormat = "decimal"
)

// Defines values for GetV4HistoricalSportsSportOddsParamsRegions.
const (
	GetV4HistoricalSportsSportOddsParamsRegionsAu    GetV4HistoricalSportsSportOddsParamsRegions = "au"
	GetV4HistoricalSportsSportOddsParamsRegionsEu    GetV4HistoricalSportsSportOddsParamsRegions = "eu"
	GetV4HistoricalSportsSportOddsParamsRegionsUk    GetV4HistoricalSportsSportOddsParamsRegions = "uk"
	GetV4HistoricalSportsSportOddsParamsRegionsUs    GetV4HistoricalSportsSportOddsParamsRegions = "us"
	GetV4HistoricalSportsSportOddsParamsRegionsUs2   GetV4HistoricalSportsSportOddsParamsRegions = "us2"
	GetV4HistoricalSportsSportOddsParamsRegionsUsDfs GetV4HistoricalSportsSportOddsParamsRegions = "us_dfs"
)

// Defines values for GetV4HistoricalSportsSportOddsParamsMarkets.
const (
	GetV4HistoricalSportsSportOddsParamsMarketsH2h       GetV4HistoricalSportsSportOddsParamsMarkets = "h2h"
	GetV4HistoricalSportsSportOddsParamsMarketsOutrights GetV4HistoricalSportsSportOddsParamsMarkets = "outrights"
	GetV4HistoricalSportsSportOddsParamsMarketsSpreads   GetV4HistoricalSportsSportOddsParamsMarkets = "spreads"
	GetV4HistoricalSportsSportOddsParamsMarketsTotals    GetV4HistoricalSportsSportOddsParamsMarkets = "totals"
)

// Defines values for GetV4HistoricalSportsSportOddsParamsDateFormat.
const (
	GetV4HistoricalSportsSportOddsParamsDateFormatIso  GetV4HistoricalSportsSportOddsParamsDateFormat = "iso"
	GetV4HistoricalSportsSportOddsParamsDateFormatUnix GetV4HistoricalSportsSportOddsParamsDateFormat = "unix"
)

// Defines values for GetV4HistoricalSportsSportOddsParamsOddsFormat.
const (
	GetV4HistoricalSportsSportOddsParamsOddsFormatAmerican GetV4HistoricalSportsSportOddsParamsOddsFormat = "american"
	GetV4HistoricalSportsSportOddsParamsOddsFormatDecimal  GetV4HistoricalSportsSportOddsParamsOddsFormat = "decimal"
)

// Defines values for GetV4SportsSportEventsParamsDateFormat.
const (
	GetV4SportsSportEventsParamsDateFormatIso  GetV4SportsSportEventsParamsDateFormat = "iso"
	GetV4SportsSportEventsParamsDateFormatUnix GetV4SportsSportEventsParamsDateFormat = "unix"
)

// Defines values for GetV4SportsSportEventsEventIdOddsParamsRegions.
const (
	GetV4SportsSportEventsEventIdOddsParamsRegionsAu    GetV4SportsSportEventsEventIdOddsParamsRegions = "au"
	GetV4SportsSportEventsEventIdOddsParamsRegionsEu    GetV4SportsSportEventsEventIdOddsParamsRegions = "eu"
	GetV4SportsSportEventsEventIdOddsParamsRegionsUk    GetV4SportsSportEventsEventIdOddsParamsRegions = "uk"
	GetV4SportsSportEventsEventIdOddsParamsRegionsUs    GetV4SportsSportEventsEventIdOddsParamsRegions = "us"
	GetV4SportsSportEventsEventIdOddsParamsRegionsUs2   GetV4SportsSportEventsEventIdOddsParamsRegions = "us2"
	GetV4SportsSportEventsEventIdOddsParamsRegionsUsDfs GetV4SportsSportEventsEventIdOddsParamsRegions = "us_dfs"
)

// Defines values for GetV4SportsSportEventsEventIdOddsParamsDateFormat.
const (
	GetV4SportsSportEventsEventIdOddsParamsDateFormatIso  GetV4SportsSportEventsEventIdOddsParamsDateFormat = "iso"
	GetV4SportsSportEventsEventIdOddsParamsDateFormatUnix GetV4SportsSportEventsEventIdOddsParamsDateFormat = "unix"
)

// Defines values for GetV4SportsSportEventsEventIdOddsParamsOddsFormat.
const (
	GetV4SportsSportEventsEventIdOddsParamsOddsFormatAmerican GetV4SportsSportEventsEventIdOddsParamsOddsFormat = "american"
	GetV4SportsSportEventsEventIdOddsParamsOddsFormatDecimal  GetV4SportsSportEventsEventIdOddsParamsOddsFormat = "decimal"
)

// Defines values for GetV4SportsSportOddsParamsRegions.
const (
	GetV4SportsSportOddsParamsRegionsAu    GetV4SportsSportOddsParamsRegions = "au"
	GetV4SportsSportOddsParamsRegionsEu    GetV4SportsSportOddsParamsRegions = "eu"
	GetV4SportsSportOddsParamsRegionsUk    GetV4SportsSportOddsParamsRegions = "uk"
	GetV4SportsSportOddsParamsRegionsUs    GetV4SportsSportOddsParamsRegions = "us"
	GetV4SportsSportOddsParamsRegionsUs2   GetV4SportsSportOddsParamsRegions = "us2"
	GetV4SportsSportOddsParamsRegionsUsDfs GetV4SportsSportOddsParamsRegions = "us_dfs"
)

// Defines values for GetV4SportsSportOddsParamsMarkets.
const (
	GetV4SportsSportOddsParamsMarketsH2h       GetV4SportsSportOddsParamsMarkets = "h2h"
	GetV4SportsSportOddsParamsMarketsOutrights GetV4SportsSportOddsParamsMarkets = "outrights"
	GetV4SportsSportOddsParamsMarketsSpreads   GetV4SportsSportOddsParamsMarkets = "spreads"
	GetV4SportsSportOddsParamsMarketsTotals    GetV4SportsSportOddsParamsMarkets = "totals"
)

// Defines values for GetV4SportsSportOddsParamsDateFormat.
const (
	GetV4SportsSportOddsParamsDateFormatIso  GetV4SportsSportOddsParamsDateFormat = "iso"
	GetV4SportsSportOddsParamsDateFormatUnix GetV4SportsSportOddsParamsDateFormat = "unix"
)

// Defines values for GetV4SportsSportOddsParamsOddsFormat.
const (
	GetV4SportsSportOddsParamsOddsFormatAmerican GetV4SportsSportOddsParamsOddsFormat = "american"
	GetV4SportsSportOddsParamsOddsFormatDecimal  GetV4SportsSportOddsParamsOddsFormat = "decimal"
)

// Defines values for GetV4SportsSportScoresParamsDateFormat.
const (
	Iso  GetV4SportsSportScoresParamsDateFormat = "iso"
	Unix GetV4SportsSportScoresParamsDateFormat = "unix"
)

// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
type AwayTeam = string

// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
type CommenceTime = time.Time

// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
type HomeTeam = string

// MatchId A unique 32 character identifier for the event.
type MatchId = string

// Outcome defines model for Outcome.
type Outcome struct {
	// BetLimit The bookmaker's or exchange's monetary limit on the betting selection. The currency will depend on the bookmaker/exchange. This field is included when providing the query parameter includeBetLimits=true, and is mainly populated for betting exchanges.
	BetLimit *float32 `json:"bet_limit"`

	// Description This field is only relevant for certain markets. It contains more information about the outcome (for example, for player prop markets, it includes the player's name)
	Description *string `json:"description"`

	// Link If available, link to the bookmaker's website and populate the betslip. This field is included when providing the query parameter includeLinks=true
	Link *string `json:"link"`

	// Name The outcome label. The value will depend on the market. For totals markets, this will be 'Over' or 'Under'. For team markets, it will be the name of the team or participant, or 'Draw'
	Name *string `json:"name,omitempty"`

	// Point The handicap or points of the outcome, only applicable to spreads and totals markets (this property will be missing for h2h and outrights markets)
	Point *float32 `json:"point"`

	// Price The odds of the outcome. The format is determined by the oddsFormat query param. The format is decimal by default.
	Price *float32 `json:"price,omitempty"`

	// Sid The bookmaker's id for the bet selection, if available. This field is included when providing the query parameter includeSids=true
	Sid *string `json:"sid"`
}

// ScoreModel defines model for ScoreModel.
type ScoreModel struct {
	// Name The participant name
	Name *string `json:"name,omitempty"`

	// Score The most recent score for the participant
	Score *string `json:"score,omitempty"`
}

// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
type SportKey = string

// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
type SportTitle = string

// GetV4HistoricalSportsSportEventsParams defines parameters for GetV4HistoricalSportsSportEvents.
type GetV4HistoricalSportsSportEventsParams struct {
	// ApiKey Access key (40 characters). Get an API key at https://the-odds-api.com/#get-access
	ApiKey string `form:"apiKey" json:"apiKey"`

	// DateFormat Format of returned timestamps. Can be iso (ISO8601) or unix timestamp (seconds since epoch)
	DateFormat *GetV4HistoricalSportsSportEventsParamsDateFormat `form:"dateFormat,omitempty" json:"dateFormat,omitempty"`

	// EventIds Comma-separated event ids. Filters the response to only return events for the specified ids, provided those events have not expired
	EventIds *string `form:"eventIds,omitempty" json:"eventIds,omitempty"`

	// CommenceTimeFrom Filters the response to show events that commence on and after this parameter. Values are in ISO8601 format
	CommenceTimeFrom *string `form:"commenceTimeFrom,omitempty" json:"commenceTimeFrom,omitempty"`

	// CommenceTimeTo Filters the response to show events that commence on and before this parameter. Values are in ISO8601 format
	CommenceTimeTo *string `form:"commenceTimeTo,omitempty" json:"commenceTimeTo,omitempty"`

	// Date The timestamp of the data snapshot to be returned, specified in ISO8601 format. The API will return the closest snapshot equal to or earlier than the provided date parameter
	Date string `form:"date" json:"date"`
}

// GetV4HistoricalSportsSportEventsParamsDateFormat defines parameters for GetV4HistoricalSportsSportEvents.
type GetV4HistoricalSportsSportEventsParamsDateFormat string

// GetV4HistoricalSportsSportEventsEventIdOddsParams defines parameters for GetV4HistoricalSportsSportEventsEventIdOdds.
type GetV4HistoricalSportsSportEventsEventIdOddsParams struct {
	// ApiKey Access key (40 characters). Get an API key at https://the-odds-api.com/#get-access
	ApiKey string `form:"apiKey" json:"apiKey"`

	// Regions Determines which bookmakers appear in the response. Multiple regions can be specified if comma delimited. Most use cases will only need to specify one region. See [the full list of bookmakers by region](https://the-odds-api.com/sports-odds-data/bookmaker-apis.html)
	Regions GetV4HistoricalSportsSportEventsEventIdOddsParamsRegions `form:"regions" json:"regions"`

	// Markets The odds markets to return. Multiple markets can be specified if comma delimited. Defaults to h2h (head to head / moneyline). Outrights only avaialable for select sports. See [the full list of supported market keys](https://the-odds-api.com/sports-odds-data/betting-markets.html)
	Markets *string `form:"markets,omitempty" json:"markets,omitempty"`

	// DateFormat Format of returned timestamps. Can be iso (ISO8601) or unix timestamp (seconds since epoch)
	DateFormat *GetV4HistoricalSportsSportEventsEventIdOddsParamsDateFormat `form:"dateFormat,omitempty" json:"dateFormat,omitempty"`

	// OddsFormat Format of returned odds
	OddsFormat *GetV4HistoricalSportsSportEventsEventIdOddsParamsOddsFormat `form:"oddsFormat,omitempty" json:"oddsFormat,omitempty"`

	// Bookmakers Comma-separated list of bookmakers to be returned. If both `bookmakers` and `regions` are specified, `bookmakers` takes precendence. Bookmakers can be from any region. Every group of 10 bookmakers counts as 1 request. For example for a single market, specifying up to 10 bookmakers counts as 1 request. Specifying between 11 and 20 bookmakers counts as 2 requests
	Bookmakers *string `form:"bookmakers,omitempty" json:"bookmakers,omitempty"`

	// Date The timestamp of the data snapshot to be returned, specified in ISO8601 format. The API will return the closest snapshot equal to or earlier than the provided date parameter
	Date string `form:"date" json:"date"`
}

// GetV4HistoricalSportsSportEventsEventIdOddsParamsRegions defines parameters for GetV4HistoricalSportsSportEventsEventIdOdds.
type GetV4HistoricalSportsSportEventsEventIdOddsParamsRegions string

// GetV4HistoricalSportsSportEventsEventIdOddsParamsDateFormat defines parameters for GetV4HistoricalSportsSportEventsEventIdOdds.
type GetV4HistoricalSportsSportEventsEventIdOddsParamsDateFormat string

// GetV4HistoricalSportsSportEventsEventIdOddsParamsOddsFormat defines parameters for GetV4HistoricalSportsSportEventsEventIdOdds.
type GetV4HistoricalSportsSportEventsEventIdOddsParamsOddsFormat string

// GetV4HistoricalSportsSportOddsParams defines parameters for GetV4HistoricalSportsSportOdds.
type GetV4HistoricalSportsSportOddsParams struct {
	// ApiKey Access key (40 characters). Get an API key at https://the-odds-api.com/#get-access
	ApiKey string `form:"apiKey" json:"apiKey"`

	// Regions Determines which bookmakers appear in the response. Multiple regions can be specified if comma delimited. Most use cases will only need to specify one region. For a list of bookmakers by region, see https://the-odds-api.com/sports-odds-data/bookmaker-apis.html
	Regions GetV4HistoricalSportsSportOddsParamsRegions `form:"regions" json:"regions"`

	// Markets The odds market to return. Multiple markets can be specified if comma delimited. Defaults to h2h (head to head / moneyline). Outrights are only avaialable for select sports, such as golf.
	Markets *GetV4HistoricalSportsSportOddsParamsMarkets `form:"markets,omitempty" json:"markets,omitempty"`

	// DateFormat Format of returned timestamps. Can be iso (ISO8601) or unix timestamp (seconds since epoch)
	DateFormat *GetV4HistoricalSportsSportOddsParamsDateFormat `form:"dateFormat,omitempty" json:"dateFormat,omitempty"`

	// OddsFormat Format of returned odds
	OddsFormat *GetV4HistoricalSportsSportOddsParamsOddsFormat `form:"oddsFormat,omitempty" json:"oddsFormat,omitempty"`

	// EventIds Comma-separated event ids. Filters the response to only return events for the specified ids, provided those events have not expired
	EventIds *string `form:"eventIds,omitempty" json:"eventIds,omitempty"`

	// Bookmakers Comma-separated list of bookmakers to be returned. If both `bookmakers` and `regions` are specified, `bookmakers` takes precendence. Bookmakers can be from any region. Every group of 10 bookmakers counts as 1 request. For example for a single market, specifying up to 10 bookmakers counts as 1 request. Specifying between 11 and 20 bookmakers counts as 2 requests
	Bookmakers *string `form:"bookmakers,omitempty" json:"bookmakers,omitempty"`

	// Date The timestamp of the data snapshot to be returned, specified in ISO8601 format. The historical odds API will return the closest snapshot equal to or earlier than the provided date parameter
	Date string `form:"date" json:"date"`
}

// GetV4HistoricalSportsSportOddsParamsRegions defines parameters for GetV4HistoricalSportsSportOdds.
type GetV4HistoricalSportsSportOddsParamsRegions string

// GetV4HistoricalSportsSportOddsParamsMarkets defines parameters for GetV4HistoricalSportsSportOdds.
type GetV4HistoricalSportsSportOddsParamsMarkets string

// GetV4HistoricalSportsSportOddsParamsDateFormat defines parameters for GetV4HistoricalSportsSportOdds.
type GetV4HistoricalSportsSportOddsParamsDateFormat string

// GetV4HistoricalSportsSportOddsParamsOddsFormat defines parameters for GetV4HistoricalSportsSportOdds.
type GetV4HistoricalSportsSportOddsParamsOddsFormat string

// GetV4SportsParams defines parameters for GetV4Sports.
type GetV4SportsParams struct {
	// ApiKey Get an API key at https://the-odds-api.com/#get-access
	ApiKey string `form:"apiKey" json:"apiKey"`

	// All When excluded, only recently updated (in-season) sports appear. Include this paramter to see all available sports
	All *bool `form:"all,omitempty" json:"all,omitempty"`
}

// GetV4SportsSportEventsParams defines parameters for GetV4SportsSportEvents.
type GetV4SportsSportEventsParams struct {
	// ApiKey Access key (40 characters). Get an API key at https://the-odds-api.com/#get-access
	ApiKey string `form:"apiKey" json:"apiKey"`

	// DateFormat Format of returned timestamps. Can be iso (ISO8601) or unix timestamp (seconds since epoch)
	DateFormat *GetV4SportsSportEventsParamsDateFormat `form:"dateFormat,omitempty" json:"dateFormat,omitempty"`

	// EventIds Comma-separated event ids. Filters the response to only return events for the specified ids, provided those events have not expired
	EventIds *string `form:"eventIds,omitempty" json:"eventIds,omitempty"`

	// CommenceTimeFrom Filters the response to show events that commence on and after this parameter. Values are in ISO8601 format
	CommenceTimeFrom *string `form:"commenceTimeFrom,omitempty" json:"commenceTimeFrom,omitempty"`

	// CommenceTimeTo Filters the response to show events that commence on and before this parameter. Values are in ISO8601 format
	CommenceTimeTo *string `form:"commenceTimeTo,omitempty" json:"commenceTimeTo,omitempty"`
}

// GetV4SportsSportEventsParamsDateFormat defines parameters for GetV4SportsSportEvents.
type GetV4SportsSportEventsParamsDateFormat string

// GetV4SportsSportEventsEventIdOddsParams defines parameters for GetV4SportsSportEventsEventIdOdds.
type GetV4SportsSportEventsEventIdOddsParams struct {
	// ApiKey Access key (40 characters). Get an API key at https://the-odds-api.com/#get-access
	ApiKey string `form:"apiKey" json:"apiKey"`

	// Regions Determines which bookmakers appear in the response. Multiple regions can be specified if comma delimited. Each region will count as 1 request against the usage quota for each market. Most use cases will only need to specify one region. See [the full list of bookmakers by region](https://the-odds-api.com/sports-odds-data/bookmaker-apis.html)
	Regions GetV4SportsSportEventsEventIdOddsParamsRegions `form:"regions" json:"regions"`

	// Markets The odds markets to return. Multiple markets can be specified if comma delimited. Defaults to h2h (head to head / moneyline). Outrights only avaialable for select sports. See [the full list of supported market keys](https://the-odds-api.com/sports-odds-data/betting-markets.html)
	Markets *string `form:"markets,omitempty" json:"markets,omitempty"`

	// DateFormat Format of returned timestamps. Can be iso (ISO8601) or unix timestamp (seconds since epoch)
	DateFormat *GetV4SportsSportEventsEventIdOddsParamsDateFormat `form:"dateFormat,omitempty" json:"dateFormat,omitempty"`

	// OddsFormat Format of returned odds
	OddsFormat *GetV4SportsSportEventsEventIdOddsParamsOddsFormat `form:"oddsFormat,omitempty" json:"oddsFormat,omitempty"`

	// Bookmakers Comma-separated list of bookmakers to be returned. If both `bookmakers` and `regions` are specified, `bookmakers` takes precendence. Bookmakers can be from any region. Every group of 10 bookmakers counts as 1 request. For example for a single market, specifying up to 10 bookmakers counts as 1 request. Specifying between 11 and 20 bookmakers counts as 2 requests
	Bookmakers *string `form:"bookmakers,omitempty" json:"bookmakers,omitempty"`

	// IncludeLinks The response will include bookmaker links to events, markets, and betslips if available.
	IncludeLinks *bool `form:"includeLinks,omitempty" json:"includeLinks,omitempty"`

	// IncludeSids The response will include source ids (bookmaker ids) for events, markets, and outcomes if available.
	IncludeSids *bool `form:"includeSids,omitempty" json:"includeSids,omitempty"`

	// IncludeBetLimits The response will include the bet limit of each betting option, mainly available for betting exchanges.
	IncludeBetLimits *bool `form:"includeBetLimits,omitempty" json:"includeBetLimits,omitempty"`
}

// GetV4SportsSportEventsEventIdOddsParamsRegions defines parameters for GetV4SportsSportEventsEventIdOdds.
type GetV4SportsSportEventsEventIdOddsParamsRegions string

// GetV4SportsSportEventsEventIdOddsParamsDateFormat defines parameters for GetV4SportsSportEventsEventIdOdds.
type GetV4SportsSportEventsEventIdOddsParamsDateFormat string

// GetV4SportsSportEventsEventIdOddsParamsOddsFormat defines parameters for GetV4SportsSportEventsEventIdOdds.
type GetV4SportsSportEventsEventIdOddsParamsOddsFormat string

// GetV4SportsSportOddsParams defines parameters for GetV4SportsSportOdds.
type GetV4SportsSportOddsParams struct {
	// ApiKey Access key (40 characters). Get an API key at https://the-odds-api.com/#get-access
	ApiKey string `form:"apiKey" json:"apiKey"`

	// Regions Determines which bookmakers appear in the response. Multiple regions can be specified if comma delimited. Each region will count as 1 request against the usage quota for each market. Most use cases will only need to specify one region. For a list of bookmakers by region, see https://the-odds-api.com/sports-odds-data/bookmaker-apis.html
	Regions GetV4SportsSportOddsParamsRegions `form:"regions" json:"regions"`

	// Markets The odds market to return. Multiple markets can be specified if comma delimited. Defaults to h2h (head to head / moneyline). Outrights are only avaialable for select sports, such as golf.
	Markets *GetV4SportsSportOddsParamsMarkets `form:"markets,omitempty" json:"markets,omitempty"`

	// DateFormat Format of returned timestamps. Can be iso (ISO8601) or unix timestamp (seconds since epoch)
	DateFormat *GetV4SportsSportOddsParamsDateFormat `form:"dateFormat,omitempty" json:"dateFormat,omitempty"`

	// OddsFormat Format of returned odds
	OddsFormat *GetV4SportsSportOddsParamsOddsFormat `form:"oddsFormat,omitempty" json:"oddsFormat,omitempty"`

	// EventIds Comma-separated event ids. Filters the response to only return events for the specified ids, provided those events have not expired
	EventIds *string `form:"eventIds,omitempty" json:"eventIds,omitempty"`

	// Bookmakers Comma-separated list of bookmakers to be returned. If both `bookmakers` and `regions` are specified, `bookmakers` takes precendence. Bookmakers can be from any region. Every group of 10 bookmakers counts as 1 request. For example for a single market, specifying up to 10 bookmakers is the equivalent of 1 region. Specifying between 11 and 20 bookmakers is the equivalent of 2 regions
	Bookmakers *string `form:"bookmakers,omitempty" json:"bookmakers,omitempty"`

	// CommenceTimeFrom Filters the response to show events that commence on and after this parameter. Values are in ISO8601 format
	CommenceTimeFrom *string `form:"commenceTimeFrom,omitempty" json:"commenceTimeFrom,omitempty"`

	// CommenceTimeTo Filters the response to show events that commence on and before this parameter. Values are in ISO8601 format
	CommenceTimeTo *string `form:"commenceTimeTo,omitempty" json:"commenceTimeTo,omitempty"`

	// IncludeLinks The response will include bookmaker links to events, markets, and betslips if available.
	IncludeLinks *bool `form:"includeLinks,omitempty" json:"includeLinks,omitempty"`

	// IncludeSids The response will include source ids (bookmaker ids) for events, markets, and outcomes if available.
	IncludeSids *bool `form:"includeSids,omitempty" json:"includeSids,omitempty"`

	// IncludeBetLimits The response will include the bet limit of each betting option, mainly available for betting exchanges.
	IncludeBetLimits *bool `form:"includeBetLimits,omitempty" json:"includeBetLimits,omitempty"`
}

// GetV4SportsSportOddsParamsRegions defines parameters for GetV4SportsSportOdds.
type GetV4SportsSportOddsParamsRegions string

// GetV4SportsSportOddsParamsMarkets defines parameters for GetV4SportsSportOdds.
type GetV4SportsSportOddsParamsMarkets string

// GetV4SportsSportOddsParamsDateFormat defines parameters for GetV4SportsSportOdds.
type GetV4SportsSportOddsParamsDateFormat string

// GetV4SportsSportOddsParamsOddsFormat defines parameters for GetV4SportsSportOdds.
type GetV4SportsSportOddsParamsOddsFormat string

// GetV4SportsSportParticipantsParams defines parameters for GetV4SportsSportParticipants.
type GetV4SportsSportParticipantsParams struct {
	// ApiKey Access key (40 characters). Get an API key at https://the-odds-api.com/#get-access
	ApiKey string `form:"apiKey" json:"apiKey"`
}

// GetV4SportsSportScoresParams defines parameters for GetV4SportsSportScores.
type GetV4SportsSportScoresParams struct {
	// ApiKey Access key (40 characters). Get an API key at https://the-odds-api.com/#get-access
	ApiKey string `form:"apiKey" json:"apiKey"`

	// DaysFrom The number of days in the past from which to return completed events. Valid values are integers from `1` to `3`. If this field is missing, only live and upcoming events are returned.
	DaysFrom *int `form:"daysFrom,omitempty" json:"daysFrom,omitempty"`

	// DateFormat Format of returned timestamps. Can be iso (ISO8601) or unix timestamp (seconds since epoch)
	DateFormat *GetV4SportsSportScoresParamsDateFormat `form:"dateFormat,omitempty" json:"dateFormat,omitempty"`

	// EventIds Comma-separated event ids. Filters the response to only return events for the specified ids, provided those events have not expired
	EventIds *string `form:"eventIds,omitempty" json:"eventIds,omitempty"`
}

// GetV4SportsSportScoresParamsDateFormat defines parameters for GetV4SportsSportScores.
type GetV4SportsSportScoresParamsDateFormat string

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetV4HistoricalSportsSportEvents request
	GetV4HistoricalSportsSportEvents(ctx context.Context, sport string, params *GetV4HistoricalSportsSportEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV4HistoricalSportsSportEventsEventIdOdds request
	GetV4HistoricalSportsSportEventsEventIdOdds(ctx context.Context, sport string, eventId string, params *GetV4HistoricalSportsSportEventsEventIdOddsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV4HistoricalSportsSportOdds request
	GetV4HistoricalSportsSportOdds(ctx context.Context, sport string, params *GetV4HistoricalSportsSportOddsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV4Sports request
	GetV4Sports(ctx context.Context, params *GetV4SportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV4SportsSportEvents request
	GetV4SportsSportEvents(ctx context.Context, sport string, params *GetV4SportsSportEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV4SportsSportEventsEventIdOdds request
	GetV4SportsSportEventsEventIdOdds(ctx context.Context, sport string, eventId string, params *GetV4SportsSportEventsEventIdOddsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV4SportsSportOdds request
	GetV4SportsSportOdds(ctx context.Context, sport string, params *GetV4SportsSportOddsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV4SportsSportParticipants request
	GetV4SportsSportParticipants(ctx context.Context, sport string, params *GetV4SportsSportParticipantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV4SportsSportScores request
	GetV4SportsSportScores(ctx context.Context, sport string, params *GetV4SportsSportScoresParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetV4HistoricalSportsSportEvents(ctx context.Context, sport string, params *GetV4HistoricalSportsSportEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV4HistoricalSportsSportEventsRequest(c.Server, sport, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV4HistoricalSportsSportEventsEventIdOdds(ctx context.Context, sport string, eventId string, params *GetV4HistoricalSportsSportEventsEventIdOddsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV4HistoricalSportsSportEventsEventIdOddsRequest(c.Server, sport, eventId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV4HistoricalSportsSportOdds(ctx context.Context, sport string, params *GetV4HistoricalSportsSportOddsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV4HistoricalSportsSportOddsRequest(c.Server, sport, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV4Sports(ctx context.Context, params *GetV4SportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV4SportsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV4SportsSportEvents(ctx context.Context, sport string, params *GetV4SportsSportEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV4SportsSportEventsRequest(c.Server, sport, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV4SportsSportEventsEventIdOdds(ctx context.Context, sport string, eventId string, params *GetV4SportsSportEventsEventIdOddsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV4SportsSportEventsEventIdOddsRequest(c.Server, sport, eventId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV4SportsSportOdds(ctx context.Context, sport string, params *GetV4SportsSportOddsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV4SportsSportOddsRequest(c.Server, sport, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV4SportsSportParticipants(ctx context.Context, sport string, params *GetV4SportsSportParticipantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV4SportsSportParticipantsRequest(c.Server, sport, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV4SportsSportScores(ctx context.Context, sport string, params *GetV4SportsSportScoresParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV4SportsSportScoresRequest(c.Server, sport, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetV4HistoricalSportsSportEventsRequest generates requests for GetV4HistoricalSportsSportEvents
func NewGetV4HistoricalSportsSportEventsRequest(server string, sport string, params *GetV4HistoricalSportsSportEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sport", runtime.ParamLocationPath, sport)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/historical/sports/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "apiKey", runtime.ParamLocationQuery, params.ApiKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DateFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateFormat", runtime.ParamLocationQuery, *params.DateFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventIds", runtime.ParamLocationQuery, *params.EventIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommenceTimeFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commenceTimeFrom", runtime.ParamLocationQuery, *params.CommenceTimeFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommenceTimeTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commenceTimeTo", runtime.ParamLocationQuery, *params.CommenceTimeTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, params.Date); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV4HistoricalSportsSportEventsEventIdOddsRequest generates requests for GetV4HistoricalSportsSportEventsEventIdOdds
func NewGetV4HistoricalSportsSportEventsEventIdOddsRequest(server string, sport string, eventId string, params *GetV4HistoricalSportsSportEventsEventIdOddsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sport", runtime.ParamLocationPath, sport)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "eventId", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/historical/sports/%s/events/%s/odds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "apiKey", runtime.ParamLocationQuery, params.ApiKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "regions", runtime.ParamLocationQuery, params.Regions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Markets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "markets", runtime.ParamLocationQuery, *params.Markets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateFormat", runtime.ParamLocationQuery, *params.DateFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OddsFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oddsFormat", runtime.ParamLocationQuery, *params.OddsFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Bookmakers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bookmakers", runtime.ParamLocationQuery, *params.Bookmakers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, params.Date); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV4HistoricalSportsSportOddsRequest generates requests for GetV4HistoricalSportsSportOdds
func NewGetV4HistoricalSportsSportOddsRequest(server string, sport string, params *GetV4HistoricalSportsSportOddsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sport", runtime.ParamLocationPath, sport)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/historical/sports/%s/odds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "apiKey", runtime.ParamLocationQuery, params.ApiKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "regions", runtime.ParamLocationQuery, params.Regions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Markets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "markets", runtime.ParamLocationQuery, *params.Markets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateFormat", runtime.ParamLocationQuery, *params.DateFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OddsFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oddsFormat", runtime.ParamLocationQuery, *params.OddsFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventIds", runtime.ParamLocationQuery, *params.EventIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Bookmakers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bookmakers", runtime.ParamLocationQuery, *params.Bookmakers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, params.Date); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV4SportsRequest generates requests for GetV4Sports
func NewGetV4SportsRequest(server string, params *GetV4SportsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/sports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "apiKey", runtime.ParamLocationQuery, params.ApiKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.All != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all", runtime.ParamLocationQuery, *params.All); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV4SportsSportEventsRequest generates requests for GetV4SportsSportEvents
func NewGetV4SportsSportEventsRequest(server string, sport string, params *GetV4SportsSportEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sport", runtime.ParamLocationPath, sport)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/sports/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "apiKey", runtime.ParamLocationQuery, params.ApiKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DateFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateFormat", runtime.ParamLocationQuery, *params.DateFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventIds", runtime.ParamLocationQuery, *params.EventIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommenceTimeFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commenceTimeFrom", runtime.ParamLocationQuery, *params.CommenceTimeFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommenceTimeTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commenceTimeTo", runtime.ParamLocationQuery, *params.CommenceTimeTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV4SportsSportEventsEventIdOddsRequest generates requests for GetV4SportsSportEventsEventIdOdds
func NewGetV4SportsSportEventsEventIdOddsRequest(server string, sport string, eventId string, params *GetV4SportsSportEventsEventIdOddsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sport", runtime.ParamLocationPath, sport)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "eventId", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/sports/%s/events/%s/odds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "apiKey", runtime.ParamLocationQuery, params.ApiKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "regions", runtime.ParamLocationQuery, params.Regions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Markets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "markets", runtime.ParamLocationQuery, *params.Markets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateFormat", runtime.ParamLocationQuery, *params.DateFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OddsFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oddsFormat", runtime.ParamLocationQuery, *params.OddsFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Bookmakers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bookmakers", runtime.ParamLocationQuery, *params.Bookmakers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeLinks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeLinks", runtime.ParamLocationQuery, *params.IncludeLinks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSids", runtime.ParamLocationQuery, *params.IncludeSids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeBetLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeBetLimits", runtime.ParamLocationQuery, *params.IncludeBetLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV4SportsSportOddsRequest generates requests for GetV4SportsSportOdds
func NewGetV4SportsSportOddsRequest(server string, sport string, params *GetV4SportsSportOddsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sport", runtime.ParamLocationPath, sport)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/sports/%s/odds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "apiKey", runtime.ParamLocationQuery, params.ApiKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "regions", runtime.ParamLocationQuery, params.Regions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Markets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "markets", runtime.ParamLocationQuery, *params.Markets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateFormat", runtime.ParamLocationQuery, *params.DateFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OddsFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oddsFormat", runtime.ParamLocationQuery, *params.OddsFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventIds", runtime.ParamLocationQuery, *params.EventIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Bookmakers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bookmakers", runtime.ParamLocationQuery, *params.Bookmakers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommenceTimeFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commenceTimeFrom", runtime.ParamLocationQuery, *params.CommenceTimeFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommenceTimeTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commenceTimeTo", runtime.ParamLocationQuery, *params.CommenceTimeTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeLinks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeLinks", runtime.ParamLocationQuery, *params.IncludeLinks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSids", runtime.ParamLocationQuery, *params.IncludeSids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeBetLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeBetLimits", runtime.ParamLocationQuery, *params.IncludeBetLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV4SportsSportParticipantsRequest generates requests for GetV4SportsSportParticipants
func NewGetV4SportsSportParticipantsRequest(server string, sport string, params *GetV4SportsSportParticipantsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sport", runtime.ParamLocationPath, sport)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/sports/%s/participants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "apiKey", runtime.ParamLocationQuery, params.ApiKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV4SportsSportScoresRequest generates requests for GetV4SportsSportScores
func NewGetV4SportsSportScoresRequest(server string, sport string, params *GetV4SportsSportScoresParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sport", runtime.ParamLocationPath, sport)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/sports/%s/scores", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "apiKey", runtime.ParamLocationQuery, params.ApiKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DaysFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "daysFrom", runtime.ParamLocationQuery, *params.DaysFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateFormat", runtime.ParamLocationQuery, *params.DateFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventIds", runtime.ParamLocationQuery, *params.EventIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetV4HistoricalSportsSportEventsWithResponse request
	GetV4HistoricalSportsSportEventsWithResponse(ctx context.Context, sport string, params *GetV4HistoricalSportsSportEventsParams, reqEditors ...RequestEditorFn) (*GetV4HistoricalSportsSportEventsResponse, error)

	// GetV4HistoricalSportsSportEventsEventIdOddsWithResponse request
	GetV4HistoricalSportsSportEventsEventIdOddsWithResponse(ctx context.Context, sport string, eventId string, params *GetV4HistoricalSportsSportEventsEventIdOddsParams, reqEditors ...RequestEditorFn) (*GetV4HistoricalSportsSportEventsEventIdOddsResponse, error)

	// GetV4HistoricalSportsSportOddsWithResponse request
	GetV4HistoricalSportsSportOddsWithResponse(ctx context.Context, sport string, params *GetV4HistoricalSportsSportOddsParams, reqEditors ...RequestEditorFn) (*GetV4HistoricalSportsSportOddsResponse, error)

	// GetV4SportsWithResponse request
	GetV4SportsWithResponse(ctx context.Context, params *GetV4SportsParams, reqEditors ...RequestEditorFn) (*GetV4SportsResponse, error)

	// GetV4SportsSportEventsWithResponse request
	GetV4SportsSportEventsWithResponse(ctx context.Context, sport string, params *GetV4SportsSportEventsParams, reqEditors ...RequestEditorFn) (*GetV4SportsSportEventsResponse, error)

	// GetV4SportsSportEventsEventIdOddsWithResponse request
	GetV4SportsSportEventsEventIdOddsWithResponse(ctx context.Context, sport string, eventId string, params *GetV4SportsSportEventsEventIdOddsParams, reqEditors ...RequestEditorFn) (*GetV4SportsSportEventsEventIdOddsResponse, error)

	// GetV4SportsSportOddsWithResponse request
	GetV4SportsSportOddsWithResponse(ctx context.Context, sport string, params *GetV4SportsSportOddsParams, reqEditors ...RequestEditorFn) (*GetV4SportsSportOddsResponse, error)

	// GetV4SportsSportParticipantsWithResponse request
	GetV4SportsSportParticipantsWithResponse(ctx context.Context, sport string, params *GetV4SportsSportParticipantsParams, reqEditors ...RequestEditorFn) (*GetV4SportsSportParticipantsResponse, error)

	// GetV4SportsSportScoresWithResponse request
	GetV4SportsSportScoresWithResponse(ctx context.Context, sport string, params *GetV4SportsSportScoresParams, reqEditors ...RequestEditorFn) (*GetV4SportsSportScoresResponse, error)
}

type GetV4HistoricalSportsSportEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A list of live and upcoming events
		Data *[]struct {
			// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			AwayTeam *AwayTeam `json:"away_team"`

			// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
			CommenceTime *CommenceTime `json:"commence_time,omitempty"`

			// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			HomeTeam *HomeTeam `json:"home_team"`

			// Id A unique 32 character identifier for the event.
			Id *MatchId `json:"id,omitempty"`

			// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
			SportKey *SportKey `json:"sport_key,omitempty"`

			// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
			SportTitle *SportTitle `json:"sport_title,omitempty"`
		} `json:"data,omitempty"`

		// NextTimestamp The next available timestamp. This can be used as the date parameter in a new request to move forward in time.
		NextTimestamp *string `json:"next_timestamp,omitempty"`

		// PreviousTimestamp The preceding available timestamp. This can be used as the date parameter in a new request to move back in time.
		PreviousTimestamp *string `json:"previous_timestamp,omitempty"`

		// Timestamp The timestamp of the snapshot. This will be the closest available timestamp equal to or earlier than the provided date parameter.
		Timestamp *string `json:"timestamp,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetV4HistoricalSportsSportEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV4HistoricalSportsSportEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV4HistoricalSportsSportEventsEventIdOddsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			AwayTeam   *AwayTeam `json:"away_team"`
			Bookmakers *[]struct {
				// Key A unique slug (key) of the bookmaker
				Key *string `json:"key,omitempty"`

				// Markets The included market depends on the specified 'markets' GET param.
				Markets *[]struct {
					// Key The unique key for the odds market
					Key *string `json:"key,omitempty"`

					// LastUpdate A timestamp of when the markets's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string.
					LastUpdate *time.Time `json:"last_update,omitempty"`
					Outcomes   *[]Outcome `json:"outcomes,omitempty"`
				} `json:"markets,omitempty"`

				// Title A formatted title of the bookmaker
				Title *string `json:"title,omitempty"`
			} `json:"bookmakers,omitempty"`

			// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
			CommenceTime *CommenceTime `json:"commence_time,omitempty"`

			// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			HomeTeam *HomeTeam `json:"home_team"`

			// Id A unique 32 character identifier for the event.
			Id *MatchId `json:"id,omitempty"`

			// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
			SportKey *SportKey `json:"sport_key,omitempty"`

			// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
			SportTitle *SportTitle `json:"sport_title,omitempty"`
		} `json:"data,omitempty"`

		// NextTimestamp The next available timestamp. This can be used as the date parameter in a new request to move forward in time.
		NextTimestamp *string `json:"next_timestamp,omitempty"`

		// PreviousTimestamp The preceding available timestamp. This can be used as the date parameter in a new request to move back in time.
		PreviousTimestamp *string `json:"previous_timestamp,omitempty"`

		// Timestamp The timestamp of the snapshot. This will be the closest available timestamp equal to or earlier than the provided date parameter.
		Timestamp *string `json:"timestamp,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetV4HistoricalSportsSportEventsEventIdOddsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV4HistoricalSportsSportEventsEventIdOddsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV4HistoricalSportsSportOddsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A list of live and upcoming events at the time of the snapshot
		Data *[]struct {
			// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			AwayTeam   *AwayTeam `json:"away_team"`
			Bookmakers *[]struct {
				// Key A unique slug (key) of the bookmaker
				Key *string `json:"key,omitempty"`

				// LastUpdate A timestamp of when the bookmaker's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string
				LastUpdate *time.Time `json:"last_update,omitempty"`

				// Markets The included market depends on the specified 'markets' GET param. NOTE Allow for the addition of new market types in future.
				Markets *[]struct {
					// Key The name of the odds market
					Key *GetV4HistoricalSportsSportOdds200DataBookmakersMarketsKey `json:"key,omitempty"`

					// LastUpdate A timestamp of when the markets's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string. To check recency of odds, we recommend using this field instead of the "last_update" field at the bookmaker level.
					LastUpdate *time.Time `json:"last_update,omitempty"`
					Outcomes   *[]Outcome `json:"outcomes,omitempty"`
				} `json:"markets,omitempty"`

				// Title A formatted title of the bookmaker
				Title *string `json:"title,omitempty"`
			} `json:"bookmakers,omitempty"`

			// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
			CommenceTime *CommenceTime `json:"commence_time,omitempty"`

			// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			HomeTeam *HomeTeam `json:"home_team"`

			// Id A unique 32 character identifier for the event.
			Id *MatchId `json:"id,omitempty"`

			// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
			SportKey *SportKey `json:"sport_key,omitempty"`

			// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
			SportTitle *SportTitle `json:"sport_title,omitempty"`
		} `json:"data,omitempty"`

		// NextTimestamp The next available timestamp. This can be used as the date parameter in a new request to move forward in time.
		NextTimestamp *string `json:"next_timestamp,omitempty"`

		// PreviousTimestamp The preceding available timestamp. This can be used as the date parameter in a new request to move back in time.
		PreviousTimestamp *string `json:"previous_timestamp,omitempty"`

		// Timestamp The timestamp of the snapshot. This will be the closest available timestamp equal to or earlier than the provided date parameter.
		Timestamp *string `json:"timestamp,omitempty"`
	}
}
type GetV4HistoricalSportsSportOdds200DataBookmakersMarketsKey string

// Status returns HTTPResponse.Status
func (r GetV4HistoricalSportsSportOddsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV4HistoricalSportsSportOddsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV4SportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Active Indicates if the sport is in season
		Active *bool `json:"active,omitempty"`

		// Description A brief description of the sport. Subject to change (for example, if sponsors change)
		Description *string `json:"description,omitempty"`

		// Group A broader grouping
		Group *string `json:"group,omitempty"`

		// HasOutrights Indicates if the sport has outrights markets.
		HasOutrights *bool `json:"has_outrights,omitempty"`

		// Key A unique slug for the sport. Use this as the "sport" param in /odds requests
		Key *SportKey `json:"key,omitempty"`

		// Title A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
		Title *SportTitle `json:"title,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetV4SportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV4SportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV4SportsSportEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
		AwayTeam *AwayTeam `json:"away_team"`

		// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
		CommenceTime *CommenceTime `json:"commence_time,omitempty"`

		// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
		HomeTeam *HomeTeam `json:"home_team"`

		// Id A unique 32 character identifier for the event.
		Id *MatchId `json:"id,omitempty"`

		// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
		SportKey *SportKey `json:"sport_key,omitempty"`

		// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
		SportTitle *SportTitle `json:"sport_title,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetV4SportsSportEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV4SportsSportEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV4SportsSportEventsEventIdOddsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
		AwayTeam   *AwayTeam `json:"away_team"`
		Bookmakers *[]struct {
			// Key A unique slug (key) of the bookmaker
			Key *string `json:"key,omitempty"`

			// Link Link to the event on the bookmaker's website if available. This field is included when providing the query parameter includeLinks=true
			Link *string `json:"link"`

			// Markets The included market depends on the specified 'markets' GET param.
			Markets *[]struct {
				// Key The unique key for the odds market
				Key *string `json:"key,omitempty"`

				// LastUpdate A timestamp of when the markets's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string.
				LastUpdate *time.Time `json:"last_update,omitempty"`

				// Link Link to the market on the bookmaker's website if applicable. This field is included when providing the query parameter includeLinks=true
				Link     *string    `json:"link"`
				Outcomes *[]Outcome `json:"outcomes,omitempty"`

				// Sid The bookmaker's id of the market if available. This field is included when providing the query parameter includeSids=true
				Sid *string `json:"sid"`
			} `json:"markets,omitempty"`

			// Sid The bookmaker's id of the event if available. This field is included when providing the query parameter includeSids=true
			Sid *string `json:"sid"`

			// Title A formatted title of the bookmaker
			Title *string `json:"title,omitempty"`
		} `json:"bookmakers,omitempty"`

		// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
		CommenceTime *CommenceTime `json:"commence_time,omitempty"`

		// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
		HomeTeam *HomeTeam `json:"home_team"`

		// Id A unique 32 character identifier for the event.
		Id *MatchId `json:"id,omitempty"`

		// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
		SportKey *SportKey `json:"sport_key,omitempty"`

		// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
		SportTitle *SportTitle `json:"sport_title,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetV4SportsSportEventsEventIdOddsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV4SportsSportEventsEventIdOddsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV4SportsSportOddsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
		AwayTeam   *AwayTeam `json:"away_team"`
		Bookmakers *[]struct {
			// Key A unique slug (key) of the bookmaker
			Key *string `json:"key,omitempty"`

			// LastUpdate A timestamp of when the bookmaker's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string
			LastUpdate *time.Time `json:"last_update,omitempty"`

			// Link Link to the event on the bookmaker's website if available. This field is included when providing the query parameter includeLinks=true
			Link *string `json:"link"`

			// Markets The included market depends on the specified 'markets' GET param. NOTE Allow for the addition of new market types in future.
			Markets *[]struct {
				// Key The name of the odds market
				Key *GetV4SportsSportOdds200BookmakersMarketsKey `json:"key,omitempty"`

				// LastUpdate A timestamp of when the markets's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string. To check recency of odds, we recommend using this field instead of the "last_update" field at the bookmaker level.
				LastUpdate *time.Time `json:"last_update,omitempty"`

				// Link Link to the market on the bookmaker's website if applicable. This field is included when providing the query parameter includeLinks=true
				Link     *string    `json:"link"`
				Outcomes *[]Outcome `json:"outcomes,omitempty"`

				// Sid The bookmaker's id of the market if available. This field is included when providing the query parameter includeSids=true
				Sid *string `json:"sid"`
			} `json:"markets,omitempty"`

			// Sid The bookmaker's id of the event if available. This field is included when providing the query parameter includeSids=true
			Sid *string `json:"sid"`

			// Title A formatted title of the bookmaker
			Title *string `json:"title,omitempty"`
		} `json:"bookmakers,omitempty"`

		// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
		CommenceTime *CommenceTime `json:"commence_time,omitempty"`

		// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
		HomeTeam *HomeTeam `json:"home_team"`

		// Id A unique 32 character identifier for the event.
		Id *MatchId `json:"id,omitempty"`

		// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
		SportKey *SportKey `json:"sport_key,omitempty"`

		// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
		SportTitle *SportTitle `json:"sport_title,omitempty"`
	}
}
type GetV4SportsSportOdds200BookmakersMarketsKey string

// Status returns HTTPResponse.Status
func (r GetV4SportsSportOddsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV4SportsSportOddsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV4SportsSportParticipantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// FullName The participant name. Either a team name, or player name depending on the sport. This endpoint does not return players on a team.
		FullName *string `json:"full_name,omitempty"`

		// Id A unique id of the participant
		Id *string `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetV4SportsSportParticipantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV4SportsSportParticipantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV4SportsSportScoresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
		AwayTeam *AwayTeam `json:"away_team"`

		// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
		CommenceTime *CommenceTime `json:"commence_time,omitempty"`

		// Completed true if the event has finished, otherwise false
		Completed *bool `json:"completed,omitempty"`

		// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
		HomeTeam *HomeTeam `json:"home_team"`

		// Id A unique 32 character identifier for the event.
		Id *MatchId `json:"id,omitempty"`

		// LastUpdate ISO8601 datetime of when the scores were last updated. Will be null if event has not started
		LastUpdate *string `json:"last_update"`

		// Scores A list of teams and their scores. List will be empty if event has not started.
		Scores *[]ScoreModel `json:"scores,omitempty"`

		// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
		SportKey *SportKey `json:"sport_key,omitempty"`

		// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
		SportTitle *SportTitle `json:"sport_title,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetV4SportsSportScoresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV4SportsSportScoresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetV4HistoricalSportsSportEventsWithResponse request returning *GetV4HistoricalSportsSportEventsResponse
func (c *ClientWithResponses) GetV4HistoricalSportsSportEventsWithResponse(ctx context.Context, sport string, params *GetV4HistoricalSportsSportEventsParams, reqEditors ...RequestEditorFn) (*GetV4HistoricalSportsSportEventsResponse, error) {
	rsp, err := c.GetV4HistoricalSportsSportEvents(ctx, sport, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV4HistoricalSportsSportEventsResponse(rsp)
}

// GetV4HistoricalSportsSportEventsEventIdOddsWithResponse request returning *GetV4HistoricalSportsSportEventsEventIdOddsResponse
func (c *ClientWithResponses) GetV4HistoricalSportsSportEventsEventIdOddsWithResponse(ctx context.Context, sport string, eventId string, params *GetV4HistoricalSportsSportEventsEventIdOddsParams, reqEditors ...RequestEditorFn) (*GetV4HistoricalSportsSportEventsEventIdOddsResponse, error) {
	rsp, err := c.GetV4HistoricalSportsSportEventsEventIdOdds(ctx, sport, eventId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV4HistoricalSportsSportEventsEventIdOddsResponse(rsp)
}

// GetV4HistoricalSportsSportOddsWithResponse request returning *GetV4HistoricalSportsSportOddsResponse
func (c *ClientWithResponses) GetV4HistoricalSportsSportOddsWithResponse(ctx context.Context, sport string, params *GetV4HistoricalSportsSportOddsParams, reqEditors ...RequestEditorFn) (*GetV4HistoricalSportsSportOddsResponse, error) {
	rsp, err := c.GetV4HistoricalSportsSportOdds(ctx, sport, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV4HistoricalSportsSportOddsResponse(rsp)
}

// GetV4SportsWithResponse request returning *GetV4SportsResponse
func (c *ClientWithResponses) GetV4SportsWithResponse(ctx context.Context, params *GetV4SportsParams, reqEditors ...RequestEditorFn) (*GetV4SportsResponse, error) {
	rsp, err := c.GetV4Sports(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV4SportsResponse(rsp)
}

// GetV4SportsSportEventsWithResponse request returning *GetV4SportsSportEventsResponse
func (c *ClientWithResponses) GetV4SportsSportEventsWithResponse(ctx context.Context, sport string, params *GetV4SportsSportEventsParams, reqEditors ...RequestEditorFn) (*GetV4SportsSportEventsResponse, error) {
	rsp, err := c.GetV4SportsSportEvents(ctx, sport, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV4SportsSportEventsResponse(rsp)
}

// GetV4SportsSportEventsEventIdOddsWithResponse request returning *GetV4SportsSportEventsEventIdOddsResponse
func (c *ClientWithResponses) GetV4SportsSportEventsEventIdOddsWithResponse(ctx context.Context, sport string, eventId string, params *GetV4SportsSportEventsEventIdOddsParams, reqEditors ...RequestEditorFn) (*GetV4SportsSportEventsEventIdOddsResponse, error) {
	rsp, err := c.GetV4SportsSportEventsEventIdOdds(ctx, sport, eventId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV4SportsSportEventsEventIdOddsResponse(rsp)
}

// GetV4SportsSportOddsWithResponse request returning *GetV4SportsSportOddsResponse
func (c *ClientWithResponses) GetV4SportsSportOddsWithResponse(ctx context.Context, sport string, params *GetV4SportsSportOddsParams, reqEditors ...RequestEditorFn) (*GetV4SportsSportOddsResponse, error) {
	rsp, err := c.GetV4SportsSportOdds(ctx, sport, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV4SportsSportOddsResponse(rsp)
}

// GetV4SportsSportParticipantsWithResponse request returning *GetV4SportsSportParticipantsResponse
func (c *ClientWithResponses) GetV4SportsSportParticipantsWithResponse(ctx context.Context, sport string, params *GetV4SportsSportParticipantsParams, reqEditors ...RequestEditorFn) (*GetV4SportsSportParticipantsResponse, error) {
	rsp, err := c.GetV4SportsSportParticipants(ctx, sport, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV4SportsSportParticipantsResponse(rsp)
}

// GetV4SportsSportScoresWithResponse request returning *GetV4SportsSportScoresResponse
func (c *ClientWithResponses) GetV4SportsSportScoresWithResponse(ctx context.Context, sport string, params *GetV4SportsSportScoresParams, reqEditors ...RequestEditorFn) (*GetV4SportsSportScoresResponse, error) {
	rsp, err := c.GetV4SportsSportScores(ctx, sport, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV4SportsSportScoresResponse(rsp)
}

// ParseGetV4HistoricalSportsSportEventsResponse parses an HTTP response from a GetV4HistoricalSportsSportEventsWithResponse call
func ParseGetV4HistoricalSportsSportEventsResponse(rsp *http.Response) (*GetV4HistoricalSportsSportEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV4HistoricalSportsSportEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A list of live and upcoming events
			Data *[]struct {
				// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
				AwayTeam *AwayTeam `json:"away_team"`

				// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
				CommenceTime *CommenceTime `json:"commence_time,omitempty"`

				// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
				HomeTeam *HomeTeam `json:"home_team"`

				// Id A unique 32 character identifier for the event.
				Id *MatchId `json:"id,omitempty"`

				// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
				SportKey *SportKey `json:"sport_key,omitempty"`

				// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
				SportTitle *SportTitle `json:"sport_title,omitempty"`
			} `json:"data,omitempty"`

			// NextTimestamp The next available timestamp. This can be used as the date parameter in a new request to move forward in time.
			NextTimestamp *string `json:"next_timestamp,omitempty"`

			// PreviousTimestamp The preceding available timestamp. This can be used as the date parameter in a new request to move back in time.
			PreviousTimestamp *string `json:"previous_timestamp,omitempty"`

			// Timestamp The timestamp of the snapshot. This will be the closest available timestamp equal to or earlier than the provided date parameter.
			Timestamp *string `json:"timestamp,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV4HistoricalSportsSportEventsEventIdOddsResponse parses an HTTP response from a GetV4HistoricalSportsSportEventsEventIdOddsWithResponse call
func ParseGetV4HistoricalSportsSportEventsEventIdOddsResponse(rsp *http.Response) (*GetV4HistoricalSportsSportEventsEventIdOddsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV4HistoricalSportsSportEventsEventIdOddsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
				AwayTeam   *AwayTeam `json:"away_team"`
				Bookmakers *[]struct {
					// Key A unique slug (key) of the bookmaker
					Key *string `json:"key,omitempty"`

					// Markets The included market depends on the specified 'markets' GET param.
					Markets *[]struct {
						// Key The unique key for the odds market
						Key *string `json:"key,omitempty"`

						// LastUpdate A timestamp of when the markets's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string.
						LastUpdate *time.Time `json:"last_update,omitempty"`
						Outcomes   *[]Outcome `json:"outcomes,omitempty"`
					} `json:"markets,omitempty"`

					// Title A formatted title of the bookmaker
					Title *string `json:"title,omitempty"`
				} `json:"bookmakers,omitempty"`

				// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
				CommenceTime *CommenceTime `json:"commence_time,omitempty"`

				// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
				HomeTeam *HomeTeam `json:"home_team"`

				// Id A unique 32 character identifier for the event.
				Id *MatchId `json:"id,omitempty"`

				// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
				SportKey *SportKey `json:"sport_key,omitempty"`

				// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
				SportTitle *SportTitle `json:"sport_title,omitempty"`
			} `json:"data,omitempty"`

			// NextTimestamp The next available timestamp. This can be used as the date parameter in a new request to move forward in time.
			NextTimestamp *string `json:"next_timestamp,omitempty"`

			// PreviousTimestamp The preceding available timestamp. This can be used as the date parameter in a new request to move back in time.
			PreviousTimestamp *string `json:"previous_timestamp,omitempty"`

			// Timestamp The timestamp of the snapshot. This will be the closest available timestamp equal to or earlier than the provided date parameter.
			Timestamp *string `json:"timestamp,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV4HistoricalSportsSportOddsResponse parses an HTTP response from a GetV4HistoricalSportsSportOddsWithResponse call
func ParseGetV4HistoricalSportsSportOddsResponse(rsp *http.Response) (*GetV4HistoricalSportsSportOddsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV4HistoricalSportsSportOddsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A list of live and upcoming events at the time of the snapshot
			Data *[]struct {
				// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
				AwayTeam   *AwayTeam `json:"away_team"`
				Bookmakers *[]struct {
					// Key A unique slug (key) of the bookmaker
					Key *string `json:"key,omitempty"`

					// LastUpdate A timestamp of when the bookmaker's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string
					LastUpdate *time.Time `json:"last_update,omitempty"`

					// Markets The included market depends on the specified 'markets' GET param. NOTE Allow for the addition of new market types in future.
					Markets *[]struct {
						// Key The name of the odds market
						Key *GetV4HistoricalSportsSportOdds200DataBookmakersMarketsKey `json:"key,omitempty"`

						// LastUpdate A timestamp of when the markets's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string. To check recency of odds, we recommend using this field instead of the "last_update" field at the bookmaker level.
						LastUpdate *time.Time `json:"last_update,omitempty"`
						Outcomes   *[]Outcome `json:"outcomes,omitempty"`
					} `json:"markets,omitempty"`

					// Title A formatted title of the bookmaker
					Title *string `json:"title,omitempty"`
				} `json:"bookmakers,omitempty"`

				// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
				CommenceTime *CommenceTime `json:"commence_time,omitempty"`

				// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
				HomeTeam *HomeTeam `json:"home_team"`

				// Id A unique 32 character identifier for the event.
				Id *MatchId `json:"id,omitempty"`

				// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
				SportKey *SportKey `json:"sport_key,omitempty"`

				// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
				SportTitle *SportTitle `json:"sport_title,omitempty"`
			} `json:"data,omitempty"`

			// NextTimestamp The next available timestamp. This can be used as the date parameter in a new request to move forward in time.
			NextTimestamp *string `json:"next_timestamp,omitempty"`

			// PreviousTimestamp The preceding available timestamp. This can be used as the date parameter in a new request to move back in time.
			PreviousTimestamp *string `json:"previous_timestamp,omitempty"`

			// Timestamp The timestamp of the snapshot. This will be the closest available timestamp equal to or earlier than the provided date parameter.
			Timestamp *string `json:"timestamp,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV4SportsResponse parses an HTTP response from a GetV4SportsWithResponse call
func ParseGetV4SportsResponse(rsp *http.Response) (*GetV4SportsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV4SportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Active Indicates if the sport is in season
			Active *bool `json:"active,omitempty"`

			// Description A brief description of the sport. Subject to change (for example, if sponsors change)
			Description *string `json:"description,omitempty"`

			// Group A broader grouping
			Group *string `json:"group,omitempty"`

			// HasOutrights Indicates if the sport has outrights markets.
			HasOutrights *bool `json:"has_outrights,omitempty"`

			// Key A unique slug for the sport. Use this as the "sport" param in /odds requests
			Key *SportKey `json:"key,omitempty"`

			// Title A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
			Title *SportTitle `json:"title,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV4SportsSportEventsResponse parses an HTTP response from a GetV4SportsSportEventsWithResponse call
func ParseGetV4SportsSportEventsResponse(rsp *http.Response) (*GetV4SportsSportEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV4SportsSportEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			AwayTeam *AwayTeam `json:"away_team"`

			// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
			CommenceTime *CommenceTime `json:"commence_time,omitempty"`

			// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			HomeTeam *HomeTeam `json:"home_team"`

			// Id A unique 32 character identifier for the event.
			Id *MatchId `json:"id,omitempty"`

			// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
			SportKey *SportKey `json:"sport_key,omitempty"`

			// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
			SportTitle *SportTitle `json:"sport_title,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV4SportsSportEventsEventIdOddsResponse parses an HTTP response from a GetV4SportsSportEventsEventIdOddsWithResponse call
func ParseGetV4SportsSportEventsEventIdOddsResponse(rsp *http.Response) (*GetV4SportsSportEventsEventIdOddsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV4SportsSportEventsEventIdOddsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			AwayTeam   *AwayTeam `json:"away_team"`
			Bookmakers *[]struct {
				// Key A unique slug (key) of the bookmaker
				Key *string `json:"key,omitempty"`

				// Link Link to the event on the bookmaker's website if available. This field is included when providing the query parameter includeLinks=true
				Link *string `json:"link"`

				// Markets The included market depends on the specified 'markets' GET param.
				Markets *[]struct {
					// Key The unique key for the odds market
					Key *string `json:"key,omitempty"`

					// LastUpdate A timestamp of when the markets's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string.
					LastUpdate *time.Time `json:"last_update,omitempty"`

					// Link Link to the market on the bookmaker's website if applicable. This field is included when providing the query parameter includeLinks=true
					Link     *string    `json:"link"`
					Outcomes *[]Outcome `json:"outcomes,omitempty"`

					// Sid The bookmaker's id of the market if available. This field is included when providing the query parameter includeSids=true
					Sid *string `json:"sid"`
				} `json:"markets,omitempty"`

				// Sid The bookmaker's id of the event if available. This field is included when providing the query parameter includeSids=true
				Sid *string `json:"sid"`

				// Title A formatted title of the bookmaker
				Title *string `json:"title,omitempty"`
			} `json:"bookmakers,omitempty"`

			// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
			CommenceTime *CommenceTime `json:"commence_time,omitempty"`

			// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			HomeTeam *HomeTeam `json:"home_team"`

			// Id A unique 32 character identifier for the event.
			Id *MatchId `json:"id,omitempty"`

			// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
			SportKey *SportKey `json:"sport_key,omitempty"`

			// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
			SportTitle *SportTitle `json:"sport_title,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV4SportsSportOddsResponse parses an HTTP response from a GetV4SportsSportOddsWithResponse call
func ParseGetV4SportsSportOddsResponse(rsp *http.Response) (*GetV4SportsSportOddsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV4SportsSportOddsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			AwayTeam   *AwayTeam `json:"away_team"`
			Bookmakers *[]struct {
				// Key A unique slug (key) of the bookmaker
				Key *string `json:"key,omitempty"`

				// LastUpdate A timestamp of when the bookmaker's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string
				LastUpdate *time.Time `json:"last_update,omitempty"`

				// Link Link to the event on the bookmaker's website if available. This field is included when providing the query parameter includeLinks=true
				Link *string `json:"link"`

				// Markets The included market depends on the specified 'markets' GET param. NOTE Allow for the addition of new market types in future.
				Markets *[]struct {
					// Key The name of the odds market
					Key *GetV4SportsSportOdds200BookmakersMarketsKey `json:"key,omitempty"`

					// LastUpdate A timestamp of when the markets's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string. To check recency of odds, we recommend using this field instead of the "last_update" field at the bookmaker level.
					LastUpdate *time.Time `json:"last_update,omitempty"`

					// Link Link to the market on the bookmaker's website if applicable. This field is included when providing the query parameter includeLinks=true
					Link     *string    `json:"link"`
					Outcomes *[]Outcome `json:"outcomes,omitempty"`

					// Sid The bookmaker's id of the market if available. This field is included when providing the query parameter includeSids=true
					Sid *string `json:"sid"`
				} `json:"markets,omitempty"`

				// Sid The bookmaker's id of the event if available. This field is included when providing the query parameter includeSids=true
				Sid *string `json:"sid"`

				// Title A formatted title of the bookmaker
				Title *string `json:"title,omitempty"`
			} `json:"bookmakers,omitempty"`

			// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
			CommenceTime *CommenceTime `json:"commence_time,omitempty"`

			// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			HomeTeam *HomeTeam `json:"home_team"`

			// Id A unique 32 character identifier for the event.
			Id *MatchId `json:"id,omitempty"`

			// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
			SportKey *SportKey `json:"sport_key,omitempty"`

			// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
			SportTitle *SportTitle `json:"sport_title,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV4SportsSportParticipantsResponse parses an HTTP response from a GetV4SportsSportParticipantsWithResponse call
func ParseGetV4SportsSportParticipantsResponse(rsp *http.Response) (*GetV4SportsSportParticipantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV4SportsSportParticipantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// FullName The participant name. Either a team name, or player name depending on the sport. This endpoint does not return players on a team.
			FullName *string `json:"full_name,omitempty"`

			// Id A unique id of the participant
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV4SportsSportScoresResponse parses an HTTP response from a GetV4SportsSportScoresWithResponse call
func ParseGetV4SportsSportScoresResponse(rsp *http.Response) (*GetV4SportsSportScoresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV4SportsSportScoresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			AwayTeam *AwayTeam `json:"away_team"`

			// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
			CommenceTime *CommenceTime `json:"commence_time,omitempty"`

			// Completed true if the event has finished, otherwise false
			Completed *bool `json:"completed,omitempty"`

			// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			HomeTeam *HomeTeam `json:"home_team"`

			// Id A unique 32 character identifier for the event.
			Id *MatchId `json:"id,omitempty"`

			// LastUpdate ISO8601 datetime of when the scores were last updated. Will be null if event has not started
			LastUpdate *string `json:"last_update"`

			// Scores A list of teams and their scores. List will be empty if event has not started.
			Scores *[]ScoreModel `json:"scores,omitempty"`

			// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
			SportKey *SportKey `json:"sport_key,omitempty"`

			// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
			SportTitle *SportTitle `json:"sport_title,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
