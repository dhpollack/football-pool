// Package theoddsapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package theoddsapi

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for GetHistoricalOddsParamsRegions.
const (
	GetHistoricalOddsParamsRegionsAu    GetHistoricalOddsParamsRegions = "au"
	GetHistoricalOddsParamsRegionsEu    GetHistoricalOddsParamsRegions = "eu"
	GetHistoricalOddsParamsRegionsUk    GetHistoricalOddsParamsRegions = "uk"
	GetHistoricalOddsParamsRegionsUs    GetHistoricalOddsParamsRegions = "us"
	GetHistoricalOddsParamsRegionsUs2   GetHistoricalOddsParamsRegions = "us2"
	GetHistoricalOddsParamsRegionsUsDfs GetHistoricalOddsParamsRegions = "us_dfs"
)

// Defines values for GetHistoricalOddsParamsMarkets.
const (
	GetHistoricalOddsParamsMarketsH2h       GetHistoricalOddsParamsMarkets = "h2h"
	GetHistoricalOddsParamsMarketsOutrights GetHistoricalOddsParamsMarkets = "outrights"
	GetHistoricalOddsParamsMarketsSpreads   GetHistoricalOddsParamsMarkets = "spreads"
	GetHistoricalOddsParamsMarketsTotals    GetHistoricalOddsParamsMarkets = "totals"
)

// Defines values for GetHistoricalOddsParamsDateFormat.
const (
	GetHistoricalOddsParamsDateFormatIso  GetHistoricalOddsParamsDateFormat = "iso"
	GetHistoricalOddsParamsDateFormatUnix GetHistoricalOddsParamsDateFormat = "unix"
)

// Defines values for GetHistoricalOddsParamsOddsFormat.
const (
	GetHistoricalOddsParamsOddsFormatAmerican GetHistoricalOddsParamsOddsFormat = "american"
	GetHistoricalOddsParamsOddsFormatDecimal  GetHistoricalOddsParamsOddsFormat = "decimal"
)

// Defines values for GetOddsParamsRegions.
const (
	GetOddsParamsRegionsAu    GetOddsParamsRegions = "au"
	GetOddsParamsRegionsEu    GetOddsParamsRegions = "eu"
	GetOddsParamsRegionsUk    GetOddsParamsRegions = "uk"
	GetOddsParamsRegionsUs    GetOddsParamsRegions = "us"
	GetOddsParamsRegionsUs2   GetOddsParamsRegions = "us2"
	GetOddsParamsRegionsUsDfs GetOddsParamsRegions = "us_dfs"
)

// Defines values for GetOddsParamsMarkets.
const (
	GetOddsParamsMarketsH2h       GetOddsParamsMarkets = "h2h"
	GetOddsParamsMarketsOutrights GetOddsParamsMarkets = "outrights"
	GetOddsParamsMarketsSpreads   GetOddsParamsMarkets = "spreads"
	GetOddsParamsMarketsTotals    GetOddsParamsMarkets = "totals"
)

// Defines values for GetOddsParamsDateFormat.
const (
	GetOddsParamsDateFormatIso  GetOddsParamsDateFormat = "iso"
	GetOddsParamsDateFormatUnix GetOddsParamsDateFormat = "unix"
)

// Defines values for GetOddsParamsOddsFormat.
const (
	GetOddsParamsOddsFormatAmerican GetOddsParamsOddsFormat = "american"
	GetOddsParamsOddsFormatDecimal  GetOddsParamsOddsFormat = "decimal"
)

// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
type AwayTeam = string

// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
type CommenceTime = time.Time

// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
type HomeTeam = string

// MatchId A unique 32 character identifier for the event.
type MatchId = string

// Outcome defines model for Outcome.
type Outcome struct {
	// BetLimit The bookmaker's or exchange's monetary limit on the betting selection. The currency will depend on the bookmaker/exchange. This field is included when providing the query parameter includeBetLimits=true, and is mainly populated for betting exchanges.
	BetLimit *float32 `json:"bet_limit"`

	// Description This field is only relevant for certain markets. It contains more information about the outcome (for example, for player prop markets, it includes the player's name)
	Description *string `json:"description"`

	// Link If available, link to the bookmaker's website and populate the betslip. This field is included when providing the query parameter includeLinks=true
	Link *string `json:"link"`

	// Name The outcome label. The value will depend on the market. For totals markets, this will be 'Over' or 'Under'. For team markets, it will be the name of the team or participant, or 'Draw'
	Name *string `json:"name,omitempty"`

	// Point The handicap or points of the outcome, only applicable to spreads and totals markets (this property will be missing for h2h and outrights markets)
	Point *float32 `json:"point"`

	// Price The odds of the outcome. The format is determined by the oddsFormat query param. The format is decimal by default.
	Price *float32 `json:"price,omitempty"`

	// Sid The bookmaker's id for the bet selection, if available. This field is included when providing the query parameter includeSids=true
	Sid *string `json:"sid"`
}

// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
type SportKey = string

// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
type SportTitle = string

// GetHistoricalOddsParams defines parameters for GetHistoricalOdds.
type GetHistoricalOddsParams struct {
	// ApiKey Access key (40 characters). Get an API key at https://the-odds-api.com/#get-access
	ApiKey string `form:"apiKey" json:"apiKey"`

	// Regions Determines which bookmakers appear in the response. Multiple regions can be specified if comma delimited. Most use cases will only need to specify one region. For a list of bookmakers by region, see https://the-odds-api.com/sports-odds-data/bookmaker-apis.html
	Regions GetHistoricalOddsParamsRegions `form:"regions" json:"regions"`

	// Markets The odds market to return. Multiple markets can be specified if comma delimited. Defaults to h2h (head to head / moneyline). Outrights are only avaialable for select sports, such as golf.
	Markets *GetHistoricalOddsParamsMarkets `form:"markets,omitempty" json:"markets,omitempty"`

	// DateFormat Format of returned timestamps. Can be iso (ISO8601) or unix timestamp (seconds since epoch)
	DateFormat *GetHistoricalOddsParamsDateFormat `form:"dateFormat,omitempty" json:"dateFormat,omitempty"`

	// OddsFormat Format of returned odds
	OddsFormat *GetHistoricalOddsParamsOddsFormat `form:"oddsFormat,omitempty" json:"oddsFormat,omitempty"`

	// EventIds Comma-separated event ids. Filters the response to only return events for the specified ids, provided those events have not expired
	EventIds *string `form:"eventIds,omitempty" json:"eventIds,omitempty"`

	// Bookmakers Comma-separated list of bookmakers to be returned. If both `bookmakers` and `regions` are specified, `bookmakers` takes precendence. Bookmakers can be from any region. Every group of 10 bookmakers counts as 1 request. For example for a single market, specifying up to 10 bookmakers counts as 1 request. Specifying between 11 and 20 bookmakers counts as 2 requests
	Bookmakers *string `form:"bookmakers,omitempty" json:"bookmakers,omitempty"`

	// Date The timestamp of the data snapshot to be returned, specified in ISO8601 format. The historical odds API will return the closest snapshot equal to or earlier than the provided date parameter
	Date string `form:"date" json:"date"`
}

// GetHistoricalOddsParamsRegions defines parameters for GetHistoricalOdds.
type GetHistoricalOddsParamsRegions string

// GetHistoricalOddsParamsMarkets defines parameters for GetHistoricalOdds.
type GetHistoricalOddsParamsMarkets string

// GetHistoricalOddsParamsDateFormat defines parameters for GetHistoricalOdds.
type GetHistoricalOddsParamsDateFormat string

// GetHistoricalOddsParamsOddsFormat defines parameters for GetHistoricalOdds.
type GetHistoricalOddsParamsOddsFormat string

// GetOddsParams defines parameters for GetOdds.
type GetOddsParams struct {
	// ApiKey Access key (40 characters). Get an API key at https://the-odds-api.com/#get-access
	ApiKey string `form:"apiKey" json:"apiKey"`

	// Regions Determines which bookmakers appear in the response. Multiple regions can be specified if comma delimited. Each region will count as 1 request against the usage quota for each market. Most use cases will only need to specify one region. For a list of bookmakers by region, see https://the-odds-api.com/sports-odds-data/bookmaker-apis.html
	Regions GetOddsParamsRegions `form:"regions" json:"regions"`

	// Markets The odds market to return. Multiple markets can be specified if comma delimited. Defaults to h2h (head to head / moneyline). Outrights are only avaialable for select sports, such as golf.
	Markets *GetOddsParamsMarkets `form:"markets,omitempty" json:"markets,omitempty"`

	// DateFormat Format of returned timestamps. Can be iso (ISO8601) or unix timestamp (seconds since epoch)
	DateFormat *GetOddsParamsDateFormat `form:"dateFormat,omitempty" json:"dateFormat,omitempty"`

	// OddsFormat Format of returned odds
	OddsFormat *GetOddsParamsOddsFormat `form:"oddsFormat,omitempty" json:"oddsFormat,omitempty"`

	// EventIds Comma-separated event ids. Filters the response to only return events for the specified ids, provided those events have not expired
	EventIds *string `form:"eventIds,omitempty" json:"eventIds,omitempty"`

	// Bookmakers Comma-separated list of bookmakers to be returned. If both `bookmakers` and `regions` are specified, `bookmakers` takes precendence. Bookmakers can be from any region. Every group of 10 bookmakers counts as 1 request. For example for a single market, specifying up to 10 bookmakers is the equivalent of 1 region. Specifying between 11 and 20 bookmakers is the equivalent of 2 regions
	Bookmakers *string `form:"bookmakers,omitempty" json:"bookmakers,omitempty"`

	// CommenceTimeFrom Filters the response to show events that commence on and after this parameter. Values are in ISO8601 format
	CommenceTimeFrom *string `form:"commenceTimeFrom,omitempty" json:"commenceTimeFrom,omitempty"`

	// CommenceTimeTo Filters the response to show events that commence on and before this parameter. Values are in ISO8601 format
	CommenceTimeTo *string `form:"commenceTimeTo,omitempty" json:"commenceTimeTo,omitempty"`

	// IncludeLinks The response will include bookmaker links to events, markets, and betslips if available.
	IncludeLinks *bool `form:"includeLinks,omitempty" json:"includeLinks,omitempty"`

	// IncludeSids The response will include source ids (bookmaker ids) for events, markets, and outcomes if available.
	IncludeSids *bool `form:"includeSids,omitempty" json:"includeSids,omitempty"`

	// IncludeBetLimits The response will include the bet limit of each betting option, mainly available for betting exchanges.
	IncludeBetLimits *bool `form:"includeBetLimits,omitempty" json:"includeBetLimits,omitempty"`
}

// GetOddsParamsRegions defines parameters for GetOdds.
type GetOddsParamsRegions string

// GetOddsParamsMarkets defines parameters for GetOdds.
type GetOddsParamsMarkets string

// GetOddsParamsDateFormat defines parameters for GetOdds.
type GetOddsParamsDateFormat string

// GetOddsParamsOddsFormat defines parameters for GetOdds.
type GetOddsParamsOddsFormat string

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetHistoricalOdds request
	GetHistoricalOdds(ctx context.Context, sport string, params *GetHistoricalOddsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOdds request
	GetOdds(ctx context.Context, sport string, params *GetOddsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetHistoricalOdds(ctx context.Context, sport string, params *GetHistoricalOddsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHistoricalOddsRequest(c.Server, sport, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOdds(ctx context.Context, sport string, params *GetOddsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOddsRequest(c.Server, sport, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetHistoricalOddsRequest generates requests for GetHistoricalOdds
func NewGetHistoricalOddsRequest(server string, sport string, params *GetHistoricalOddsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sport", runtime.ParamLocationPath, sport)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/historical/sports/%s/odds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "apiKey", runtime.ParamLocationQuery, params.ApiKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "regions", runtime.ParamLocationQuery, params.Regions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Markets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "markets", runtime.ParamLocationQuery, *params.Markets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateFormat", runtime.ParamLocationQuery, *params.DateFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OddsFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oddsFormat", runtime.ParamLocationQuery, *params.OddsFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventIds", runtime.ParamLocationQuery, *params.EventIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Bookmakers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bookmakers", runtime.ParamLocationQuery, *params.Bookmakers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, params.Date); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOddsRequest generates requests for GetOdds
func NewGetOddsRequest(server string, sport string, params *GetOddsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sport", runtime.ParamLocationPath, sport)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/sports/%s/odds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "apiKey", runtime.ParamLocationQuery, params.ApiKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "regions", runtime.ParamLocationQuery, params.Regions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Markets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "markets", runtime.ParamLocationQuery, *params.Markets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateFormat", runtime.ParamLocationQuery, *params.DateFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OddsFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oddsFormat", runtime.ParamLocationQuery, *params.OddsFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventIds", runtime.ParamLocationQuery, *params.EventIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Bookmakers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bookmakers", runtime.ParamLocationQuery, *params.Bookmakers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommenceTimeFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commenceTimeFrom", runtime.ParamLocationQuery, *params.CommenceTimeFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommenceTimeTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commenceTimeTo", runtime.ParamLocationQuery, *params.CommenceTimeTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeLinks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeLinks", runtime.ParamLocationQuery, *params.IncludeLinks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSids", runtime.ParamLocationQuery, *params.IncludeSids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeBetLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeBetLimits", runtime.ParamLocationQuery, *params.IncludeBetLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetHistoricalOddsWithResponse request
	GetHistoricalOddsWithResponse(ctx context.Context, sport string, params *GetHistoricalOddsParams, reqEditors ...RequestEditorFn) (*GetHistoricalOddsResponse, error)

	// GetOddsWithResponse request
	GetOddsWithResponse(ctx context.Context, sport string, params *GetOddsParams, reqEditors ...RequestEditorFn) (*GetOddsResponse, error)
}

type GetHistoricalOddsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A list of live and upcoming events at the time of the snapshot
		Data *[]struct {
			// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			AwayTeam   *AwayTeam `json:"away_team"`
			Bookmakers *[]struct {
				// Key A unique slug (key) of the bookmaker
				Key *string `json:"key,omitempty"`

				// LastUpdate A timestamp of when the bookmaker's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string
				LastUpdate *time.Time `json:"last_update,omitempty"`

				// Markets The included market depends on the specified 'markets' GET param. NOTE Allow for the addition of new market types in future.
				Markets *[]struct {
					// Key The name of the odds market
					Key *GetHistoricalOdds200DataBookmakersMarketsKey `json:"key,omitempty"`

					// LastUpdate A timestamp of when the markets's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string. To check recency of odds, we recommend using this field instead of the "last_update" field at the bookmaker level.
					LastUpdate *time.Time `json:"last_update,omitempty"`
					Outcomes   *[]Outcome `json:"outcomes,omitempty"`
				} `json:"markets,omitempty"`

				// Title A formatted title of the bookmaker
				Title *string `json:"title,omitempty"`
			} `json:"bookmakers,omitempty"`

			// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
			CommenceTime *CommenceTime `json:"commence_time,omitempty"`

			// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			HomeTeam *HomeTeam `json:"home_team"`

			// Id A unique 32 character identifier for the event.
			Id *MatchId `json:"id,omitempty"`

			// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
			SportKey *SportKey `json:"sport_key,omitempty"`

			// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
			SportTitle *SportTitle `json:"sport_title,omitempty"`
		} `json:"data,omitempty"`

		// NextTimestamp The next available timestamp. This can be used as the date parameter in a new request to move forward in time.
		NextTimestamp *string `json:"next_timestamp,omitempty"`

		// PreviousTimestamp The preceding available timestamp. This can be used as the date parameter in a new request to move back in time.
		PreviousTimestamp *string `json:"previous_timestamp,omitempty"`

		// Timestamp The timestamp of the snapshot. This will be the closest available timestamp equal to or earlier than the provided date parameter.
		Timestamp *string `json:"timestamp,omitempty"`
	}
}
type GetHistoricalOdds200DataBookmakersMarketsKey string

// Status returns HTTPResponse.Status
func (r GetHistoricalOddsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHistoricalOddsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOddsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
		AwayTeam   *AwayTeam `json:"away_team"`
		Bookmakers *[]struct {
			// Key A unique slug (key) of the bookmaker
			Key *string `json:"key,omitempty"`

			// LastUpdate A timestamp of when the bookmaker's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string
			LastUpdate *time.Time `json:"last_update,omitempty"`

			// Link Link to the event on the bookmaker's website if available. This field is included when providing the query parameter includeLinks=true
			Link *string `json:"link"`

			// Markets The included market depends on the specified 'markets' GET param. NOTE Allow for the addition of new market types in future.
			Markets *[]struct {
				// Key The name of the odds market
				Key *GetOdds200BookmakersMarketsKey `json:"key,omitempty"`

				// LastUpdate A timestamp of when the markets's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string. To check recency of odds, we recommend using this field instead of the "last_update" field at the bookmaker level.
				LastUpdate *time.Time `json:"last_update,omitempty"`

				// Link Link to the market on the bookmaker's website if applicable. This field is included when providing the query parameter includeLinks=true
				Link     *string    `json:"link"`
				Outcomes *[]Outcome `json:"outcomes,omitempty"`

				// Sid The bookmaker's id of the market if available. This field is included when providing the query parameter includeSids=true
				Sid *string `json:"sid"`
			} `json:"markets,omitempty"`

			// Sid The bookmaker's id of the event if available. This field is included when providing the query parameter includeSids=true
			Sid *string `json:"sid"`

			// Title A formatted title of the bookmaker
			Title *string `json:"title,omitempty"`
		} `json:"bookmakers,omitempty"`

		// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
		CommenceTime *CommenceTime `json:"commence_time,omitempty"`

		// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
		HomeTeam *HomeTeam `json:"home_team"`

		// Id A unique 32 character identifier for the event.
		Id *MatchId `json:"id,omitempty"`

		// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
		SportKey *SportKey `json:"sport_key,omitempty"`

		// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
		SportTitle *SportTitle `json:"sport_title,omitempty"`
	}
}
type GetOdds200BookmakersMarketsKey string

// Status returns HTTPResponse.Status
func (r GetOddsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOddsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetHistoricalOddsWithResponse request returning *GetHistoricalOddsResponse
func (c *ClientWithResponses) GetHistoricalOddsWithResponse(ctx context.Context, sport string, params *GetHistoricalOddsParams, reqEditors ...RequestEditorFn) (*GetHistoricalOddsResponse, error) {
	rsp, err := c.GetHistoricalOdds(ctx, sport, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHistoricalOddsResponse(rsp)
}

// GetOddsWithResponse request returning *GetOddsResponse
func (c *ClientWithResponses) GetOddsWithResponse(ctx context.Context, sport string, params *GetOddsParams, reqEditors ...RequestEditorFn) (*GetOddsResponse, error) {
	rsp, err := c.GetOdds(ctx, sport, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOddsResponse(rsp)
}

// ParseGetHistoricalOddsResponse parses an HTTP response from a GetHistoricalOddsWithResponse call
func ParseGetHistoricalOddsResponse(rsp *http.Response) (*GetHistoricalOddsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHistoricalOddsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A list of live and upcoming events at the time of the snapshot
			Data *[]struct {
				// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
				AwayTeam   *AwayTeam `json:"away_team"`
				Bookmakers *[]struct {
					// Key A unique slug (key) of the bookmaker
					Key *string `json:"key,omitempty"`

					// LastUpdate A timestamp of when the bookmaker's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string
					LastUpdate *time.Time `json:"last_update,omitempty"`

					// Markets The included market depends on the specified 'markets' GET param. NOTE Allow for the addition of new market types in future.
					Markets *[]struct {
						// Key The name of the odds market
						Key *GetHistoricalOdds200DataBookmakersMarketsKey `json:"key,omitempty"`

						// LastUpdate A timestamp of when the markets's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string. To check recency of odds, we recommend using this field instead of the "last_update" field at the bookmaker level.
						LastUpdate *time.Time `json:"last_update,omitempty"`
						Outcomes   *[]Outcome `json:"outcomes,omitempty"`
					} `json:"markets,omitempty"`

					// Title A formatted title of the bookmaker
					Title *string `json:"title,omitempty"`
				} `json:"bookmakers,omitempty"`

				// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
				CommenceTime *CommenceTime `json:"commence_time,omitempty"`

				// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
				HomeTeam *HomeTeam `json:"home_team"`

				// Id A unique 32 character identifier for the event.
				Id *MatchId `json:"id,omitempty"`

				// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
				SportKey *SportKey `json:"sport_key,omitempty"`

				// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
				SportTitle *SportTitle `json:"sport_title,omitempty"`
			} `json:"data,omitempty"`

			// NextTimestamp The next available timestamp. This can be used as the date parameter in a new request to move forward in time.
			NextTimestamp *string `json:"next_timestamp,omitempty"`

			// PreviousTimestamp The preceding available timestamp. This can be used as the date parameter in a new request to move back in time.
			PreviousTimestamp *string `json:"previous_timestamp,omitempty"`

			// Timestamp The timestamp of the snapshot. This will be the closest available timestamp equal to or earlier than the provided date parameter.
			Timestamp *string `json:"timestamp,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOddsResponse parses an HTTP response from a GetOddsWithResponse call
func ParseGetOddsResponse(rsp *http.Response) (*GetOddsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOddsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// AwayTeam The away team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			AwayTeam   *AwayTeam `json:"away_team"`
			Bookmakers *[]struct {
				// Key A unique slug (key) of the bookmaker
				Key *string `json:"key,omitempty"`

				// LastUpdate A timestamp of when the bookmaker's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string
				LastUpdate *time.Time `json:"last_update,omitempty"`

				// Link Link to the event on the bookmaker's website if available. This field is included when providing the query parameter includeLinks=true
				Link *string `json:"link"`

				// Markets The included market depends on the specified 'markets' GET param. NOTE Allow for the addition of new market types in future.
				Markets *[]struct {
					// Key The name of the odds market
					Key *GetOdds200BookmakersMarketsKey `json:"key,omitempty"`

					// LastUpdate A timestamp of when the markets's odds were last read. Will be an integer if dateFormat=unix, otherwise it will be a string. To check recency of odds, we recommend using this field instead of the "last_update" field at the bookmaker level.
					LastUpdate *time.Time `json:"last_update,omitempty"`

					// Link Link to the market on the bookmaker's website if applicable. This field is included when providing the query parameter includeLinks=true
					Link     *string    `json:"link"`
					Outcomes *[]Outcome `json:"outcomes,omitempty"`

					// Sid The bookmaker's id of the market if available. This field is included when providing the query parameter includeSids=true
					Sid *string `json:"sid"`
				} `json:"markets,omitempty"`

				// Sid The bookmaker's id of the event if available. This field is included when providing the query parameter includeSids=true
				Sid *string `json:"sid"`

				// Title A formatted title of the bookmaker
				Title *string `json:"title,omitempty"`
			} `json:"bookmakers,omitempty"`

			// CommenceTime The match start time (ISO 8601 formatted). This will be unix timestamp integer if the dateFormat query param is set to dateFormat=unix.
			CommenceTime *CommenceTime `json:"commence_time,omitempty"`

			// HomeTeam The home team. If home/away is not applicable for the sport (such as MMA and Tennis), it will be one of the participants. Null for outrights (futures) events.
			HomeTeam *HomeTeam `json:"home_team"`

			// Id A unique 32 character identifier for the event.
			Id *MatchId `json:"id,omitempty"`

			// SportKey A unique slug for the sport. Use this as the "sport" param in /odds requests
			SportKey *SportKey `json:"sport_key,omitempty"`

			// SportTitle A presentable title of the sport. Occassionally this value can change, for example if a league undergoes a name change or change in sponsorship.
			SportTitle *SportTitle `json:"sport_title,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
