// Package apiespn provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package apiespn

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// Address defines model for Address.
type Address struct {
	City    *string `json:"city,omitempty"`
	Country *string `json:"country,omitempty"`
	State   *string `json:"state,omitempty"`
}

// Competition defines model for Competition.
type Competition struct {
	Attendance            *int          `json:"attendance,omitempty"`
	Competitors           *[]Competitor `json:"competitors,omitempty"`
	ConferenceCompetition *bool         `json:"conferenceCompetition,omitempty"`
	Date                  *ESPNDateTime `json:"date,omitempty"`
	Id                    *string       `json:"id,omitempty"`
	NeutralSite           *bool         `json:"neutralSite,omitempty"`
	Status                *Status       `json:"status,omitempty"`
	Uid                   *string       `json:"uid,omitempty"`
	Venue                 *Venue        `json:"venue,omitempty"`
}

// Competitor defines model for Competitor.
type Competitor struct {
	HomeAway   *string        `json:"homeAway,omitempty"`
	Id         *string        `json:"id,omitempty"`
	Linescores *[]Linescore   `json:"linescores,omitempty"`
	Order      *int           `json:"order,omitempty"`
	Records    *[]Record      `json:"records,omitempty"`
	Score      *string        `json:"score,omitempty"`
	Statistics *[]interface{} `json:"statistics,omitempty"`
	Team       *Team          `json:"team,omitempty"`
	Type       *string        `json:"type,omitempty"`
	Uid        *string        `json:"uid,omitempty"`
	Winner     *bool          `json:"winner,omitempty"`
}

// Event defines model for Event.
type Event struct {
	Competitions *[]Competition `json:"competitions,omitempty"`
	Date         *ESPNDateTime  `json:"date,omitempty"`
	Id           *string        `json:"id,omitempty"`
	Links        *[]Link        `json:"links,omitempty"`
	Name         *string        `json:"name,omitempty"`
	Season       *EventSeason   `json:"season,omitempty"`
	ShortName    *string        `json:"shortName,omitempty"`
	Status       *Status        `json:"status,omitempty"`
	Uid          *string        `json:"uid,omitempty"`
	Week         *EventWeek     `json:"week,omitempty"`
}

// EventSeason defines model for EventSeason.
type EventSeason struct {
	Slug *string `json:"slug,omitempty"`
	Type *int    `json:"type,omitempty"`
	Year *int    `json:"year,omitempty"`
}

// EventWeek defines model for EventWeek.
type EventWeek struct {
	Number *int `json:"number,omitempty"`
}

// League defines model for League.
type League struct {
	Abbreviation *string `json:"abbreviation,omitempty"`
	Id           *string `json:"id,omitempty"`
	Name         *string `json:"name,omitempty"`
	Season       *Season `json:"season,omitempty"`
	Slug         *string `json:"slug,omitempty"`
	Uid          *string `json:"uid,omitempty"`
}

// Linescore defines model for Linescore.
type Linescore struct {
	DisplayValue *string  `json:"displayValue,omitempty"`
	Period       *int     `json:"period,omitempty"`
	Value        *float32 `json:"value,omitempty"`
}

// Link defines model for Link.
type Link struct {
	Href       *string   `json:"href,omitempty"`
	IsExternal *bool     `json:"isExternal,omitempty"`
	IsPremium  *bool     `json:"isPremium,omitempty"`
	Language   *string   `json:"language,omitempty"`
	Rel        *[]string `json:"rel,omitempty"`
	ShortText  *string   `json:"shortText,omitempty"`
	Text       *string   `json:"text,omitempty"`
}

// Record defines model for Record.
type Record struct {
	Abbreviation *string `json:"abbreviation,omitempty"`
	Name         *string `json:"name,omitempty"`
	Summary      *string `json:"summary,omitempty"`
	Type         *string `json:"type,omitempty"`
}

// Scoreboard defines model for Scoreboard.
type Scoreboard struct {
	Events  *[]Event    `json:"events,omitempty"`
	Leagues *[]League   `json:"leagues,omitempty"`
	Season  *SeasonInfo `json:"season,omitempty"`
	Week    *WeekInfo   `json:"week,omitempty"`
}

// Season defines model for Season.
type Season struct {
	DisplayName *string       `json:"displayName,omitempty"`
	EndDate     *ESPNDateTime `json:"endDate,omitempty"`
	StartDate   *ESPNDateTime `json:"startDate,omitempty"`
	Type        *SeasonType   `json:"type,omitempty"`
	Year        *int          `json:"year,omitempty"`
}

// SeasonInfo defines model for SeasonInfo.
type SeasonInfo struct {
	Type *int `json:"type,omitempty"`
	Year *int `json:"year,omitempty"`
}

// SeasonType defines model for SeasonType.
type SeasonType struct {
	Abbreviation *string `json:"abbreviation,omitempty"`
	Id           *string `json:"id,omitempty"`
	Name         *string `json:"name,omitempty"`
	Type         *int    `json:"type,omitempty"`
}

// Status defines model for Status.
type Status struct {
	Clock        *float32    `json:"clock,omitempty"`
	DisplayClock *string     `json:"displayClock,omitempty"`
	Period       *int        `json:"period,omitempty"`
	Type         *StatusType `json:"type,omitempty"`
}

// StatusType defines model for StatusType.
type StatusType struct {
	Completed   *bool   `json:"completed,omitempty"`
	Description *string `json:"description,omitempty"`
	Detail      *string `json:"detail,omitempty"`
	Id          *string `json:"id,omitempty"`
	Name        *string `json:"name,omitempty"`
	ShortDetail *string `json:"shortDetail,omitempty"`
	State       *string `json:"state,omitempty"`
}

// Team defines model for Team.
type Team struct {
	Abbreviation     *string `json:"abbreviation,omitempty"`
	AlternateColor   *string `json:"alternateColor,omitempty"`
	Color            *string `json:"color,omitempty"`
	DisplayName      *string `json:"displayName,omitempty"`
	Id               *string `json:"id,omitempty"`
	IsActive         *bool   `json:"isActive,omitempty"`
	Links            *[]Link `json:"links,omitempty"`
	Location         *string `json:"location,omitempty"`
	Logo             *string `json:"logo,omitempty"`
	Name             *string `json:"name,omitempty"`
	ShortDisplayName *string `json:"shortDisplayName,omitempty"`
	Uid              *string `json:"uid,omitempty"`
	Venue            *struct {
		Id *string `json:"id,omitempty"`
	} `json:"venue,omitempty"`
}

// Venue defines model for Venue.
type Venue struct {
	Address  *Address `json:"address,omitempty"`
	FullName *string  `json:"fullName,omitempty"`
	Id       *string  `json:"id,omitempty"`
	Indoor   *bool    `json:"indoor,omitempty"`
}

// WeekInfo defines model for WeekInfo.
type WeekInfo struct {
	Number *int `json:"number,omitempty"`
}

// GetScoreboardParams defines parameters for GetScoreboard.
type GetScoreboardParams struct {
	// Dates The date or date range for the scoreboard (e.g., 20250928)
	Dates *string `form:"dates,omitempty" json:"dates,omitempty"`

	// Week The week number
	Week *int `form:"week,omitempty" json:"week,omitempty"`

	// Seasontype The season type (1=preseason, 2=regular, 3=postseason)
	Seasontype *int `form:"seasontype,omitempty" json:"seasontype,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetScoreboard request
	GetScoreboard(ctx context.Context, params *GetScoreboardParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetScoreboard(ctx context.Context, params *GetScoreboardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScoreboardRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetScoreboardRequest generates requests for GetScoreboard
func NewGetScoreboardRequest(server string, params *GetScoreboardParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scoreboard")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Dates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dates", runtime.ParamLocationQuery, *params.Dates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Week != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "week", runtime.ParamLocationQuery, *params.Week); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasontype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasontype", runtime.ParamLocationQuery, *params.Seasontype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetScoreboardWithResponse request
	GetScoreboardWithResponse(ctx context.Context, params *GetScoreboardParams, reqEditors ...RequestEditorFn) (*GetScoreboardResponse, error)
}

type GetScoreboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Scoreboard
}

// Status returns HTTPResponse.Status
func (r GetScoreboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScoreboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetScoreboardWithResponse request returning *GetScoreboardResponse
func (c *ClientWithResponses) GetScoreboardWithResponse(ctx context.Context, params *GetScoreboardParams, reqEditors ...RequestEditorFn) (*GetScoreboardResponse, error) {
	rsp, err := c.GetScoreboard(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScoreboardResponse(rsp)
}

// ParseGetScoreboardResponse parses an HTTP response from a GetScoreboardWithResponse call
func ParseGetScoreboardResponse(rsp *http.Response) (*GetScoreboardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScoreboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Scoreboard
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
